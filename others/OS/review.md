## 第一章 绪论

1.  资源管理技术

   ​	资源复用（解决物理资源数量不足问题，可分为空分复用、时分复用）；

   ​	资源虚化（解决物理资源数量不足， 提高服务的能力和水平）；

   ​	资源抽象（处理系统的复杂性，解决资源的易用性）

2. 系统调用概念，系统调用与一般库函数的区别与联系

   **系统调用**是用户进程进入内核的接口层,又称广义指令，它是由操作系统向程序提供的程序接口，而非直接向用户提供，用户只能通过程序间接的使用这些接口

   **库函数**是语言或应用程序的一部分，可以运行在用户空间中。而系统调用是操作系统的一部分，是内核提供给用户的程序接口，运行在内核空间中，而且许多的库函数都会使用系统调用实现功能

3. 用户态核心态概念

   用户态:用户程序执行时操作系统所处的状态,具有较低特权,只能执行规定的指令,只能访问指定的寄存器和储存区

   核心态:操作系统管理程序执行时操作系统所处的状态,具有较高特权,能执行包括特权指令在内的一切指令,可以访问所有寄存器和储存区

4. 操作系统运行模型
   1. 在用户进程内执行的模型（单内核系统）

   <img src="/home/zhan/Pictures/Screenshot from 2020-12-30 20-15-25.png" alt="Screenshot from 2020-12-30 20-15-25" style="zoom: 50%;" />

   1. 作为独立进程执行的模型（微内核系统）

   <img src="/home/zhan/Pictures/Screenshot from 2020-12-30 20-14-48.png" alt="Screenshot from 2020-12-30 20-14-48" style="zoom: 50%;" />

   ​	理解好对应的几幅图

 

## 第二章 处理器管理

1. 中断/异常响应过程：

   发现中断源-->保护线程-->转向处理中断-->异常的处理程序-->恢复现场

2. 准确理解进程的上下文切换（不同进程的切换）和处理器模式切换（用户态、核心态），切换图的理解(ch2-2.3进程及其实现.ppt  25页)

   进程上下文:进程执行活动全过程的静态描述

   进程切换:进程切换是指处理器从一个进程的运行转到另一个进程的运行

   处理器模式切换:当中断/系统 调用发生时，暂时中断正在执行的用户进程，把进程从用户状态切换到内核状态，去执行操作系统服务程序以获得服务

   

<img src="/home/zhan/Pictures/Screenshot from 2020-12-30 20-20-52.png" alt="Screenshot from 2020-12-30 20-20-52" style="zoom: 67%;" />

3. 多道作业批处理系统的高级调度：

   从后备作业队列到就绪队列

4. 操作系统调度算法：

   1. 先来先服务算法、

   2. 最短作业优先算法、

   3. 最短剩余时间优先算法、

   4. 响应比最高者优先算法，

      (相关参数：作业提交时间、完成时间、周转时间、平均周转时间、作业的带权周转时间、平均作业带权周转时间)

 

## 第三章 并发进程

1. 并发进程之间的关系分类：无关的、交往的，如何判断：Bernstein条件

   例如，有如下四条语句：
    S1:  a := x + y   S2:  b := z + 1
    S3:  c := a – b   S4:  w := c + 1
    于是有：R(S1)={x,y} ,R(S2)={z}，R(S3)={a,b}，R(S4)={c}；W(S1)={a}, W(S2)={b}，W(S3)={c}，W(S4)={w}。
      S1和S2可并发执行，满足Bernstein条件。其他语句并发执行可能会产生与时间有关的错误。

2. 临界区概念：

   并发进程中与共享变量有关的程序段叫“临界区”， 

   共享变量代表的资源叫“临界资源”；

   如果各进程对共享变量的访问是互斥的（串行的），就不会造成与时间有关的错误

 

3. **信号量与PV操作**，基于PV操作的进程同步机制和原理，PV操作程序代码实现临界区及解决各种经典进程同步问题：生产者和消费者、读者和写者、吸烟者问题

   信号量：一种软件资源

   原语：内核中执行时不可被中断的过程

   P操作原语和V操作原语

   一个进程在某一特殊点上被迫停止执行直到接收到一个对应的特殊变量值，这种特殊变量就是信号量(semaphore)，复杂的进程合作需求都可以通过适当的信号结构得到满足。

   

   **一般信号量**:

   ​	P(s):将信号量s减去l，若结果小于0，则调用P(s)的进程被置成等待信号量s的状态。
   ​	V(s):将信号量s加1，若结果不大于0，则释放一个等待信号量s的进程。

   ​	推论1：若信号量s为正值，则该值等于在封锁进程之前对信号量s可施行的P操作数、亦等于s所代表的实际还可以使用的物理资源数
   ​	推论2：若信号量s为负值，则其绝对值等于登记排列在该信号量s队列之中等待的进程个数、亦即恰好等于对信号量s实施P操作而被封锁起来并进入信号量s队列的进程数
   ​	推论3：通常，P操作意味着请求一个资源，V操作意味着释放一个资源。在一定条件下，P操作代表挂起进程操作，而V操作代表唤醒被挂起进程的操作

   ````c
   typedef struct semaphore {
   	int value;             //信号量值
   	struct pcb *list;    //信号量队列指针
   
    }; 
   void P(semaphore &s) {
   	 s.value--;            
   	 if(s.value<0)         
            W(s.list);      
   }                     
   void V(semaphore &s) {
   	s.value++;            
       if(s.value<=0)        
           R(s.list);        
   }       
   ````

   ​	**抽烟者问题**:

   ````c
   semaphore offer1 = 0;
   semaphore offer2 = 0;
   semaphore offer3 = 0;
   semaphore finish = 0;
   int i = 0;
   provider(){
       while(1){
           if(i == 0){
              将组合一放桌上
              V(offer1);
           }else if(i == 1)
           {
               将组合二放桌上
               V(offer2);
           }else id(i == 2)
           {
               将组合三放桌上
               V(offer3);
           }
           i = (i+1)%3；
           P(finish);
       }
   }
   smoker1 (){
       while(1){
           P(offer1)
           从桌上拿走组合一;
           卷烟；
           抽掉；
           V(finish);
       }
   }
   
   smoker2 (){
       while(1){
           P(offer2)
           从桌上拿走组合二;
           卷烟；
           抽掉；
           V(finish);
       }
   }
   
   smoker3 (){
       while(1){
           P(offer3)
           从桌上拿走组合三;
           卷烟；
           抽掉；
           V(finish);
       }
   }
   ````

   **读者-写者问题**

   ````c
   int readcount=0;                
   
   // 初始值全为1
   semaphore resource=1;           
   semaphore rmutex=1;             
   semaphore serviceQueue=1;       // 请求按照先进先出的顺序进入队列
   
   reader() {
     serviceQueue.P();  
     // 下面的rmutex.P()和与之匹配的rmutex.V()虽然可以省略
     // 但是这样做之后缺乏可读性,所以还是不要删掉的好         
     rmutex.P();                 
     readcount++;                
     if (readcount == 1)         
       resource.P();             
     serviceQueue.V();           
     rmutex.V();                 
     readFile();
     rmutex.P();                 
     readcount--;                
     if (readcount == 0)         
       resource.V();             
     rmutex.V();                 
   }
   
   writer() {
     serviceQueue.P();           
     resource.P();               
     serviceQueue.V();           
     writeFile();
     resource.V();               
   }
   ````

   

   

4. 死锁：死锁避免算法 

   银行家算法的原理:根据系统当前的资源状况如何判断系统是否处于安全状态，银行家算法在进行资源分配前，先要考察本次分配后系统是否处于安全状态，如果安全则分配，否则不进行本次分配；

   死锁的检测和解除方案:检测当前系统是否有死锁，通过资源状态图是否能简化为完全简化图判断（死锁定理）

 

## 第四章 存储管理

1. 逻辑地址、物理地址的概念，逻辑地址空间与物理地址空间地址转换计算

   **逻辑地址**:是指程序产生的与段相关的偏移地址部分

   **物理地址**:是指出现在CPU外部地址总线上的寻址物理内存的地址信号,是逻辑地址变换后最终结果的地址

   转换:	逻辑地址=页号+页内地址=p+d;

   ​			物理地址=块号+页内地址=f+d；

2. 分页式存储管理：

   逻辑地址非显式地分解成页号和页内偏移量，页和页框，页号对应页框号通过页表实现，快表的作业，逻辑地址转换为物理地址的计算

3. 分段式存储管理：逻辑地址显式地分解成段号和段内偏移量，通过段号在段表中查找到段在物理主存的起始地址加上段内偏移量形成物理地址，地址计算及保护

4. 虚拟存储管理：指将多个不同类型、独立存在的物理存储体，通过软、硬件技术，集成转化为一个逻辑上的虚拟的存储单元，集中管理供用户统一使用。虚拟存储的好处：1、用户可以使用更多的存储单元，甚至可以超过物理主存的总量；2、用户使用虚拟存储单元时不用管该单元是否在主存中还是在辅存中，如果不在主存，系统产生缺页中断，操作系统自动调页后，继续执行，在用户看来这个过程就像未发生一样，除了执行时间拉长，这解决了存储单元的易用性问题。虚拟存储基于程序的局部性原理。判断一段程序的局部性是否好主要看其访问的虚拟存储单元地址是否具有良好的局部性。缺页中断的基本处理过程。

5. 全局页面替换策略的各种算法：

   先进先出页面替换算法FIFO

   最近最少用页面替换算法LRU

6. 局部页面替换算法：

   工作集模型

   - **工作集**：一个进程当前**正在使用的逻辑页面集合**。

     可以用一个二元函数W(t，A)来表示。其中 t 是当前的**执行时刻**；A称为**工作窗口**，即一个定长的页面访问的时间窗口。

     W(t，A) = 在当前时刻t之前的A时间窗口当中的所有页面所组成的集合（随着t的变化，该集合也在不断变化）

     |W(t，A)|指工作集的大小，即**页面数目**。

   - **常驻集**：在当前时刻，进程**实际驻留在内存当中的页面集合**。

     - 工作集是进程在运行过程中固有的性质，而常驻集取决于系统分配给进程的物理页面数目，以及所采用的页面置换算法。
     - 如果一个进程的整个工作集都在内存当中，那么进程将很顺序的运行，而不会造成太多的缺页中断（直到工作集发生剧烈变动，从而过渡到另一个状态）。
     - 当进程常驻集的大小达到某个数目之后，再给它分配更多的物理页面，缺页率也不会明显下降。

   工作集置换算法

   ​	- 思路:换出不在工作集中的页面

 

## 第五章 设备管理

1. I/O控制方式：

   ​	轮询方式

   ​	中断方式

   ​	DMA方式

   ​	通道方式

2. 缓冲技术，缓冲技术实现基本思想（ch5-5.4缓冲技术5.5驱动调度技术5.6设备分配5.7虚拟设备.ppt  p3）
   - 改善中央处理器与外围设备之间速度不配的矛盾
   - 协调逻辑记录大小与物理记录大小不一致
   - 提高CPU和I/O设备的并行性。

3. SPOOLING组成和结构和工作原理，输入井、输出井、预输入程序、缓输出程序、井管理程序

   ​	SPOOLing系统由专门负责I/O的常驻内存的进程以及输入井、输出井组成；它将独占设备改造为共享设备，实现了虚拟设备功能。

   ​	输入井和输出井：输入井和输出井的存储区域是在磁盘上开辟出来的。输入输出井中的数据一般以文件的形式组织管理，这些文件称之为井文件。

   ​	输入缓存区和输出缓存区：输入缓冲区和输出缓冲区的存储区域是在内存中开辟出来的。主要用于缓和CPU和磁盘之间速度不匹配的矛盾。输入缓冲区用于暂存有输入设备传送的数据，之后再传送到输入井；输出缓冲区同理。

   ​	输入进程和输出进程：输入进程也称为预输入进程，用于模拟脱机输入时的外围控制机，将用户要求的数据从输入设备传送到输入缓冲区，再放到输入井。

   ​	井管理程序：用于控制作业与磁盘井之间信息的交换。

 

## 第六章 文件管理

1. 操作系统支持不同类型文件：
   1. 普通文件（用于数据、代码存储）；
   2.  目录文件（操作系统中一个目录也是一个文件，它不是用于数据或代码的存储，而是为了实现对文件的索引和查找而存在的，目录文件的内容为多条文件目录项，每条目录项由inode节点号和一个相对文件名组成（不包含目录路径））；
   3. 特殊文件（包括设备文件、管道文件、套字接文件等，实现设备抽象）

2. 着重理解inode号、inode节点，它们是文件系统实现的关键

3. inode节点中的直接地址索引、一、二、三级间接地址索引的工作原理，及每种索引可以对应多大的磁盘数据存储空间的计算

   

4. 文件系统磁盘结构：

   引导块、超级块、磁盘inode区（用于存放每个文件的inode节点，该区能容纳inode的数量决定了磁盘可以存储的文件上限）、磁盘信息区（用于存储文件数据，包括普通文件和目录文件的数据）

5. 通过文件名对文件进行访问的实现过程

   例如/home/src/main.c文件，首先在文件名中查到第一个目录符/，它是根目录，它的inode号为固定值2，根据该值查出磁盘inode区的根目录inode节点，在该inode内有指向根目录目录文件在磁盘信息区的存储位置，从而读取到根目录的目录文件，在它的里面可以找到名称为home的目录项，从而得到home的inode号和home目录文件，进而得到其下的src目录项和src目录文件，最后在src中得到目录项main.c及main.c的inode节点号，根据该号找到它的inode，其中包含了main.c在磁盘信息区的存储位置，这样就可以对该数据进行存取处理。

6. inode、文件、文件名的关系：

   inode和文件是一一对应关系，有效文件名对inode是多对一关系，即一个有效的文件名对应于一个inode，但有可能有若干个文件名关联同一个inode，这些不同的文件名构成不同的硬链接，它们实际上是某些目录文件中的目录项，它们都具有相同的inode号。在inode中有一项引用计数，用于记录有多少链接指向该inode，当所有链接都删除时，计数值归0，inode以及它对应的文件才被删除释放。

 